<?php

/**
 * @file
 *
 */

/**
 * Implements hook_menu().
 *
 * Defines auto complete callbacks for the different field types.
 */
function ik_channel_filter_menu() {
  $items = array();

  $items['ik/autocomplete'] = array(
    'title' => 'Autocomplete channel filter',
    'page callback' => '_ik_channel_filter_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Autocomplete callback for the field. It searches the database for the value
 * parsed in the string variable based on the field settings.
 *
 * @param type $field_name
 *  Name of the field that makes the request for auto completion.
 * @param type $string
 *  The value/string to search for.
 */
function _ik_channel_filter_autocomplete($field_name, $string = '') {
  // Make sure the field exists and is a channel filter field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'ik_channel_filter_search') {
    echo t('Channel filter field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  $matches = array();
  if ($string != '') {
    // Search the database based on the type of content that we are looking for.
    switch ($field['settings']['ik_search']['type']) {
      case 'types':
      case 'og':
        // Find the node types to look up.
        $types = array_filter($field['settings']['ik_search'][$field['settings']['ik_search']['type']]);

        $query = db_select('node', 'n');
        $query->addTag('translatable');
        $query->addTag('content_access');

        // Select rows that match by title.
        $results = $query
          ->fields('n', array('nid', 'title'))
          ->condition('n.type', $types)
          ->condition('n.title', '%' . db_like($string) . '%', 'LIKE')
          ->range(0, 10)
          ->execute()
          ->fetchAllKeyed();
        break;

      case 'vocabulary':
        // Find vocabularies that we should search for the term.
        $vids = array();
        $vocabularies = taxonomy_vocabulary_get_names();
        foreach ($field['settings']['ik_search']['vocabulary'] as $vocabulary) {
          $vids[] = $vocabularies[$vocabulary]->vid;
        }

        $query = db_select('taxonomy_term_data', 't');
        $query->addTag('translatable');
        $query->addTag('term_access');

        // Select rows that match by term.
        $results = $query
          ->fields('t', array('tid', 'name'))
          ->condition('t.vid', $vids)
          ->condition('t.name', '%' . db_like($string) . '%', 'LIKE')
          ->range(0, 10)
          ->execute()
          ->fetchAllKeyed();
        break;

      default:
        echo t('Channel filter field @field_name do not support the selected type @type.', array(
          '@field_name' => $field_name,
          '@type' => $field['settings']['ik_search']['type'])
        );
        exit;
        break;
    }

    // Results labels may contain commas or quotes that must be wrapped in
    // quotes.
    foreach ($results as $label) {
      $n = $label;
      if (strpos($label, ',') !== FALSE || strpos($label, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $label) . '"';
      }
      $matches[$n] = check_plain($label);
    }
  }

  // Encode and return matches.
  drupal_json_output($matches);
}

/**
 * Implements hook_field_info().
 *
 */
function ik_channel_filter_field_info() {
  return array(
    'ik_channel_filter_search' => array(
      'label' => t('Channel filter'),
      'description' => t('Filter channel content base on user data'),
      'default_widget' => 'ik_filter_search_widget',
      'default_formatter' => 'ik_filter_search_formatter',
    ),
    'ik_channel_filter_preview' => array(
      'label' => t('Channel preview'),
      'description' => t('Previw channel filter results'),
      'default_widget' => 'ik_filter_search_preview',
      'default_formatter' => 'ik_filter_search_preview_formatter'
    ),
  );
}

/**
 * Implements hook_field_validate().
 *
 */
function ik_channel_filter_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

}

/**
 * Implements hook_field_is_empty().
 *
 */
function ik_channel_filter_field_is_empty($item, $field) {
  return empty($item['data']);
}

/**
 * Implements hook_field_widget_info().
 *
 * Tell Drupal about the search autocomplete widget, that should be used to
 * select the slids.
 */
function ik_channel_filter_field_widget_info() {
  return array(
    'ik_filter_search_autocomplete' => array(
      'label' => t('Default'),
      'field types' => array('ik_channel_filter_search'),
    ),
    'ik_filter_search_preview' => array(
      'label' => t('Default'),
      'field types' => array('ik_channel_filter_preview'),
    ),
    'ik_filter_search_preview_thumbnail' => array(
      'label' => t('Thumbnail'),
      'field types' => array('ik_channel_filter_preview'),
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 *
 */
function ik_channel_filter_field_settings_form($field, $instance, $has_data) {
  $settings = isset($field['settings']['ik_search']) ? $field['settings']['ik_search'] : array();
  $form = array();

  switch ($field['type']) {
    case 'ik_channel_filter_preview':
      // Get infomation about fields on current content type.
      $info = field_info_instances('node'); /* @todo: get entity type from instance */
      $info = $info[$instance['bundle']];

      // Find all channel filter fields on the current content type.
      $fields = array();
      foreach ($info as $field_name => $field_instance) {
        if ($field_instance['widget']['type'] == 'ik_filter_search_autocomplete') {
          $fields[$field_name] = filter_xss_admin($field_instance['label']);
        }
      }

      $form['ik_search']['types'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Channel filter fields'),
        '#description' => t('Select the Channel filter fields that should be used to select the slides displayed.'),
        '#options' => $fields,
        '#default_value' => isset($settings['types']) ? $settings['types'] : array(),
      );
      break;

    case 'ik_channel_filter_search':
      $form['ik_search'] = array(
        '#type' => 'fieldset',
        '#title' => t('Field search settings'),
      );

      $options = array(
        'vocabulary' => 'Vocabularies',
        'og' => 'Organic groups',
        'types' => 'Content types',
      );

      $form['ik_search']['type'] = array(
        '#type' => 'radios',
        '#title' => t('Search type'),
        '#options' => $options,
        '#default_value' => isset($settings['type']) ? $settings['type'] : '',
        '#required' => TRUE,
      );


      // Find options to display for each type defined above, when they are selected.
      $values = array(
        'vocabulary' => array(),
        'og' => array(),
        'types' => array(),
      );

      // Get all vocabulary names.
      $vocabularies = taxonomy_get_vocabularies();
      foreach ($vocabularies as $vocabulary) {
        $values['vocabulary'][$vocabulary->machine_name] = $vocabulary->name;
      }

      // Get all content type names.
      $types = node_type_get_types();
      foreach ($types as $key => $type) {
        $values['types'][$key] = $type->name;
      }

      // Get all content types that are organic groups.
      $ogs = og_get_all_group_bundle();
      foreach ($ogs['node'] as $key => $name) {
        $values['og'][$key] = $name;
      }

      // Display settings for each of the above types and display them base on the
      // one selected.
      foreach ($options as $type => $name) {
        $form['ik_search'][$type] = array(
          '#type' => 'checkboxes',
          '#title' => check_plain($name),
          '#options' => $values[$type],
          '#default_value' => isset($settings[$type]) ? $settings[$type] : array(),
          '#states' => array(
            'visible' => array(
              ':input[name="field[settings][ik_search][type]"]' => array(
                array('value' => $type),
              ),
            ),
          ),
        );
      }

      // Get all avaliable fields linked to taxonomy.
      $options = array();
      $fields = field_info_fields();
      foreach ($fields as $f) {
        if ($f['module'] == 'taxonomy') {
          $options[$f['field_name']] = $f['field_name'] . ' (' . implode(',', $f['bundles']['node']) . ')';
        }
      }

      // Display found fields, if vocabulary is selected.
      $form['ik_search']['fields'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Taxonomy fields to search'),
        '#description' => t('To speed up preformance you need to select the fields that should be searched and linked to these terms.'),
        '#options' => $options,
        '#default_value' => isset($settings['fields']) ? $settings['fields'] : array(),
        '#states' => array(
          'visible' => array(
            ':input[name="field[settings][ik_search][type]"]' => array(
              array('value' => 'vocabulary'),
            ),
          ),
        ),
      );

      $form['ik_search']['operation'] = array(
        '#type' => 'radios',
        '#title' => t('Field operations'),
        '#description' => t('The function to used between this field and other channel filter fields on this content type.'),
        '#options' => array(0 => 'AND', 1 => 'OR'),
        '#default_value' => isset($settings['operation']) ? $settings['operation'] : 0,
      );
      break;
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 *
 * The form that is used to display the widget defined above in the widget info
 * hook.
 */
function ik_channel_filter_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type' => 'fieldset',
  );

  switch ($instance['widget']['type']) {
    case 'ik_filter_search_preview':

      if (isset($element['#entity']->nid)) {
        $entity = $element['#entity'];
        $field_names = isset($field['settings']['ik_search']['types']) ? $field['settings']['ik_search']['types'] : array();

        // Start query...

        // Loop over fields and get configuration
        foreach ($field_names as $name) {
          // Check that the current field as any values
          $values = $entity->$name;
          if (empty($values)) {
            continue;
          }
          $values = $values[$langcode][$delta]['data'];

          // Get information about the fields configuration.
          $field_info = field_info_field($name);

          // User an array to store temporary tables.
          $tables = array();
          switch ($field_info['settings']['ik_search']['type']) {
            case 'types':
              // Get select content types.
              $types = array_filter($field_info['settings']['ik_search']['types']);

              // Check special case where the content type is the same as the on
              // we are creating. We have to assume that is has slides.
              if (count($types) == 1 && $entity->type == key($types)) {
                // @TODO: implement this if needed.
              }
              else {
                // Select the nodes into a temporary table.
                $query = 'SELECT n.nid, n.title
                            FROM node n
                           WHERE n.title IN (:titles)';
                $tables[] = db_query_temporary($query, array(':titles' => $values));
              }
              break;

            case 'og':
              $query = "SELECT n.nid, n.title
                        FROM og_membership ogm
                        INNER JOIN (
                          SELECT etid
                          FROM node n
                          INNER JOIN og_membership ogm ON n.nid = ogm.gid
                          WHERE n.title IN (:groups)
                          AND ogm.entity_type = 'node') inner_ogm
                        ON ogm.gid = inner_ogm.etid
                        INNER JOIN node n ON ogm.etid = n.nid
                        WHERE ogm.entity_type = 'node'";
              $tables[] = db_query_temporary($query, array(':groups' => $values));
              /**
               * INDEX TABLES with opreation type (AND || OR)
               */

              break;

            case 'vocabulary':
              $vocabularies = array_filter($field_info['settings']['ik_search']['vocabulary']);
              $term_fields = array_filter($field_info['settings']['ik_search']['fields']);

//              SELECT DISTINCT n.nid, n.title
//              FROM node n
//              INNER JOIN (
//                SELECT t1.entity_id AS etid
//                FROM taxonomy_vocabulary tv
//                INNER JOIN taxonomy_term_data ttd ON tv.vid = ttd.vid
//                INNER JOIN field_data_field_ik_slide_tags t1 ON t1.field_ik_slide_tags_tid = ttd.tid -- Dynamic join field tables.
//                WHERE machine_name IN ('tags') -- Vocabularies
//                  AND ttd.name IN ('Fly') -- Tag names
//              ) inner_n
//              ON n.nid = inner_n.etid

              break;
          }

          // Join up the temporary tables to find the nodes.
          $base = array_shift($tables);
          $query = db_select($base, 'base')
            ->fields('base', array('nid', 'title'));
          foreach ($tables as $table) {
            $query->join($table, $table, 'base.nid = ' . $table . '.nid');
          }
          $results = $query->execute()->fetchAll();

          // Return information about the slides.
          $element['message'] = array(
            '#markup' => t('@count slides found', array('@count' => count($results))),
          );

        }

        $i =1;
      }
      else {
        $element['message'] = array(
          '#markup' => t('No slides found matching filter.'),
        );
      }
      break;

    case 'ik_filter_search_preview_thumbnail':
      $element['error'] = array(
        '#markup' => t('Thumbnail preview formatter have not yet been implemented'),
      );
      break;


    case 'ik_filter_search_autocomplete':
      $field_content = isset($items[$delta]['data']) ? $items[$delta]['data'] : '';
      $element['data'] = array(
        '#type' => 'hidden',
        '#default_value' => $field_content,
        '#attributes' => array(
          'class' => array(
            'ik-channel-filter-values',
          ),
        ),
      );

      /**
       * @todo: create them funtion for this
       *
       * theme('ik_channel_filter_results', $items[$delta]['results']);
       *
       */
      $output = '';
      if (!empty($field_content)) {
        $field_items = explode(',', $field_content);
        foreach ($field_items as $item) {
          $output .= '<li><span class="value">' . $item . '</span><a class="button ik-channel-filter-remove">' . t('Remove') . '</a></li>';
        }
      }

      $element['search']['results'] = array(
        '#prefix' => '<ul class="ik-channel-filter-results">',
        '#markup' => $output,
        '#suffix' => '</ul>',
      );

      $element['search']['field'] = array(
        '#type' => 'textfield',
        '#attributes' => array(
          'placeholder' => isset($instance['default_value'][$delta]['search']['field']) ? $instance['default_value'][$delta]['search']['field'] : 'Search',
        ),
        '#attached' => array(
          'js' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/js/ik_channel_filter.js',
          ),
          'css' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/css/ik_channel_filter.css',
          ),
        ),
        '#autocomplete_path' => 'ik/autocomplete/' . $field['field_name'],
        '#required' => $element['#required'],
      );

      $element['search']['button'] = array(
        '#markup' => l(t('Add'), '#', array(
          'attributes' => array(
            'class' => array(
              'button',
              'ik-channel-filter-add-button',
            ),
          ),
        )),
      );

      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_error().
 *
 */
function ik_channel_filter_field_widget_error($element, $error, $form, &$form_state) {

}
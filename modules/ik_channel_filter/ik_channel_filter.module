<?php

/**
 * @file
 *
 */

/**
 * Implements hook_menu().
 *
 * Defines auto complete callbacks for the different field types.
 */
function ik_channel_filter_menu() {
  $items = array();
  $items['ik/autocomplete/vocabulary'] = array(
    'title' => 'Autocomplete vocabulary',
    'page callback' => '_ik_channel_filter_vocabulary_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Auto complate callback for vocabulary searches. This is a modified version of
 * the auto complete from the core taxonomy module.
 */
function _ik_channel_filter_vocabulary_autocomplete($field_name, $string = '') {
  // Make sure the field exists and is a taxonomy field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'ik_channel_filter_search') {
    print t('Channel filter field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  $term_matches = array();
  if ($string != '') {

    // Part of the criteria for the query come from the field's own settings.
    $vids = array();
    $vocabularies = taxonomy_vocabulary_get_names();
    foreach ($field['settings']['ik_search']['vocabulary'] as $vocabulary) {
      $vids[] = $vocabularies[$vocabulary]->vid;
    }

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');

    // Select rows that match by term name.
    $tags_return = $query
      ->fields('t', array('tid', 'name'))
      ->condition('t.vid', $vids)
      ->condition('t.name', '%' . db_like($string) . '%', 'LIKE')
      ->range(0, 10)
      ->execute()
      ->fetchAllKeyed();

    $term_matches = array();
    foreach ($tags_return as $tid => $name) {
      $n = $name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $name) . '"';
      }
      $term_matches[$n] = check_plain($name);
    }
  }
  drupal_json_output($term_matches);
}

/**
 * Implements hook_field_info().
 *
 */
function ik_channel_filter_field_info() {
  return array(
    'ik_channel_filter_search' => array(
      'label' => t('Channel filter'),
      'description' => t('Filter channel content base on user data'),
      'default_widget' => 'ik_filter_search_widget',
      'default_formatter' => 'ik_filter_search_formatter',
    ),
  );
}

/**
 * Implements hook_field_validate().
 *
 */
function ik_channel_filter_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

}

/**
 * Implements hook_field_is_empty().
 *
 */
function ik_channel_filter_field_is_empty($item, $field) {

}

/**
 * Implements hook_field_widget_info().
 *
 * Tell Drupal about the search autocomplete widget, that should be used to
 * select the slids.
 */
function ik_channel_filter_field_widget_info() {
  return array(
    'ik_filter_search_autocomplete' => array(
      'label' => t('Default (autocomplete)'),
      'field types' => array('ik_channel_filter_search'),
    ),
  );
}


function ik_channel_filter_field_settings_form($field, $instance, $has_data) {
  $settings = isset($field['settings']['ik_search']) ? $field['settings']['ik_search'] : array();
  $form = array();

  $form['ik_search'] = array(
    '#type' => 'fieldset',
    '#title' => t('Field search settings'),
  );

  $options = array(
    'vocabulary' => 'Vocabularies',
    'og' => 'Organic groups',
    'types' => 'Content types',
  );

  $form['ik_search']['type'] = array(
    '#type' => 'radios',
    '#title' => t('Search type'),
    '#options' => $options,
    '#default_value' => isset($settings['type']) ? $settings['type'] : '',
    '#required' => TRUE,
  );


  // Find options to display for each type defined above, when they are selected.
  $values = array(
    'vocabulary' => array(),
    'og' => array(),
    'types' => array(),
  );

  $vocabularies = taxonomy_get_vocabularies();
  foreach ($vocabularies as $vid => $vocabulary) {
    $values['vocabulary'][$vocabulary->machine_name] = $vocabulary->name;
  }

  $types = node_type_get_types();
  foreach ($types as $key => $type) {
    $values['types'][$key] = $type->name;
  }

  $ogs = og_get_all_group_bundle();
  foreach ($ogs['node'] as $key => $name) {
    $values['og'][$key] = $name;
  }

  // Display settings for each of the above types and display them base on the
  // one selected.
  foreach ($options as $type => $name) {
    $form['ik_search'][$type] = array(
      '#type' => 'checkboxes',
      '#title' => t($name),
      '#options' => $values[$type],
      '#default_value' => isset($settings[$type]) ? $settings[$type] : array(),
      '#states' => array(
        'visible' => array(
          ':input[name="field[settings][ik_search][type]"]' => array(
            array('value' => $type),
          ),
        ),
      ),
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 *
 * The form that is used to display the widget defined above in the widget info
 * hook.
 */
function ik_channel_filter_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type' => 'fieldset',
  );

  // Get element values.
  $settings = isset($field['settings']['ik_search']) ? $field['settings']['ik_search'] : array();
  $is_required = $element['#required'];

  switch ($instance['widget']['type']) {
    case 'ik_filter_search_autocomplete':

      $element['data'] = array(
        '#type' => 'hidden',
        '#default_value' => $items[$delta]['data'],
        '#attributes' => array(
          'class' => array(
            'ik-channel-filter-values',
          ),
        ),
      );

      /**
       * @todo: create them funtion for this
       *
       * theme('ik_channel_filter_results', $items[$delta]['results']);
       *
       */
      $output = '';
      $data = explode(',', $items[$delta]['data']);
      foreach ($data as $d) {
        $output .= '<li><span class="value">' . $d . '</span><a class="button ik-channel-filter-remove">' . t('Remove') . '</a></li>';
      }

      $element['search']['results'] = array(
        '#prefix' => '<ul class="ik-channel-filter-results">',
        '#markup' => $output,
        '#suffix' => '</ul>',
      );

      $element['search']['field'] = array(
        '#type' => 'textfield',
        '#attributes' => array(
          'placeholder' => isset($instance['default_value'][$delta]['search']['field']) ? $instance['default_value'][$delta]['search']['field'] : 'Search',
        ),
        '#attached' => array(
          'js' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/js/ik_channel_filter.js',
          ),
          'css' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/css/ik_channel_filter.css',
          ),
        ),
        '#autocomplete_path' => 'ik/autocomplete/' . (isset($settings['type']) ? $settings['type'] : '') . '/' . $field['field_name'],
        '#required' => $is_required,
      );

      $element['search']['button'] = array(
        '#markup' => l(t('Add'), '#', array(
          'attributes' => array(
            'class' => array(
              'button',
              'ik-channel-filter-add-button',
            ),
          ),
        )),
      );

      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_error().
 *
 */
function ik_channel_filter_field_widget_error($element, $error, $form, &$form_state) {

}

/**
 * Implements hook_field_formatter_info().
 *
 */
function ik_channel_filter_field_formatter_info() {
  return array(
    'ik_channel_filter_search_formatter' => array(
      'label' => t(''),
      'field types' => array('ik_channel_filter_search'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 *
 */
function ik_channel_filter_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {

}


<?php

/**
 * @file
 *
 */

/**
 * Implements hook_menu().
 *
 * Defines auto complete callbacks for the different field types.
 */
function ik_channel_filter_menu() {
  $items = array();

  $items['ik/autocomplete'] = array(
    'title' => 'Autocomplete channel filter',
    'page callback' => '_ik_channel_filter_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );


  return $items;
}

function _ik_channel_filter_autocomplete($field_name, $string = '') {
  // Make sure the field exists and is a channel filter field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'ik_channel_filter_search') {
    echo t('Channel filter field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  $matches = array();
  if ($string != '') {
    // Search the database based on the type of content that we are looking for.
    switch ($field['settings']['ik_search']['type']) {
      case 'types':
      case 'og':
        // Find the node types to look up.
        $types = array_filter($field['settings']['ik_search'][$field['settings']['ik_search']['type']]);

        $query = db_select('node', 'n');
        $query->addTag('translatable');
        $query->addTag('content_access');

        // Select rows that match by title.
        $results = $query
          ->fields('n', array('nid', 'title'))
          ->condition('n.type', $types)
          ->condition('n.title', '%' . db_like($string) . '%', 'LIKE')
          ->range(0, 10)
          ->execute()
          ->fetchAllKeyed();
        break;

      case 'vocabulary':
        // Find vocabularies that we should search for the term.
        $vids = array();
        $vocabularies = taxonomy_vocabulary_get_names();
        foreach ($field['settings']['ik_search']['vocabulary'] as $vocabulary) {
          $vids[] = $vocabularies[$vocabulary]->vid;
        }

        $query = db_select('taxonomy_term_data', 't');
        $query->addTag('translatable');
        $query->addTag('term_access');

        // Select rows that match by term.
        $results = $query
          ->fields('t', array('tid', 'name'))
          ->condition('t.vid', $vids)
          ->condition('t.name', '%' . db_like($string) . '%', 'LIKE')
          ->range(0, 10)
          ->execute()
          ->fetchAllKeyed();
        break;

      default:
        echo t('Channel filter field @field_name do not support the selected type @type.', array(
          '@field_name' => $field_name,
          '@type' => $field['settings']['ik_search']['type'])
        );
        exit;
        break;
    }

    // Results labels may contain commas or quotes that must be wrapped in
    // quotes.
    foreach ($results as $label) {
      $n = $label;
      if (strpos($label, ',') !== FALSE || strpos($label, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $label) . '"';
      }
      $matches[$n] = check_plain($label);
    }
  }

  // Encode and return matches.
  drupal_json_output($matches);
}

/**
 * Implements hook_field_info().
 *
 */
function ik_channel_filter_field_info() {
  return array(
    'ik_channel_filter_search' => array(
      'label' => t('Channel filter'),
      'description' => t('Filter channel content base on user data'),
      'default_widget' => 'ik_filter_search_widget',
      'default_formatter' => 'ik_filter_search_formatter',
    ),
  );
}

/**
 * Implements hook_field_validate().
 *
 */
function ik_channel_filter_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

}

/**
 * Implements hook_field_is_empty().
 *
 */
function ik_channel_filter_field_is_empty($item, $field) {
  return empty($item['data']);
}

/**
 * Implements hook_field_widget_info().
 *
 * Tell Drupal about the search autocomplete widget, that should be used to
 * select the slids.
 */
function ik_channel_filter_field_widget_info() {
  return array(
    'ik_filter_search_autocomplete' => array(
      'label' => t('Default (autocomplete)'),
      'field types' => array('ik_channel_filter_search'),
    ),
  );
}


function ik_channel_filter_field_settings_form($field, $instance, $has_data) {
  $settings = isset($field['settings']['ik_search']) ? $field['settings']['ik_search'] : array();
  $form = array();

  $form['ik_search'] = array(
    '#type' => 'fieldset',
    '#title' => t('Field search settings'),
  );

  $options = array(
    'vocabulary' => 'Vocabularies',
    'og' => 'Organic groups',
    'types' => 'Content types',
  );

  $form['ik_search']['type'] = array(
    '#type' => 'radios',
    '#title' => t('Search type'),
    '#options' => $options,
    '#default_value' => isset($settings['type']) ? $settings['type'] : '',
    '#required' => TRUE,
  );


  // Find options to display for each type defined above, when they are selected.
  $values = array(
    'vocabulary' => array(),
    'og' => array(),
    'types' => array(),
  );

  $vocabularies = taxonomy_get_vocabularies();
  foreach ($vocabularies as $vocabulary) {
    $values['vocabulary'][$vocabulary->machine_name] = $vocabulary->name;
  }

  $types = node_type_get_types();
  foreach ($types as $key => $type) {
    $values['types'][$key] = $type->name;
  }

  $ogs = og_get_all_group_bundle();
  foreach ($ogs['node'] as $key => $name) {
    $values['og'][$key] = $name;
  }

  // Display settings for each of the above types and display them base on the
  // one selected.
  foreach ($options as $type => $name) {
    $form['ik_search'][$type] = array(
      '#type' => 'checkboxes',
      '#title' => t($name),
      '#options' => $values[$type],
      '#default_value' => isset($settings[$type]) ? $settings[$type] : array(),
      '#states' => array(
        'visible' => array(
          ':input[name="field[settings][ik_search][type]"]' => array(
            array('value' => $type),
          ),
        ),
      ),
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 *
 * The form that is used to display the widget defined above in the widget info
 * hook.
 */
function ik_channel_filter_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type' => 'fieldset',
  );

  switch ($instance['widget']['type']) {
    case 'ik_filter_search_autocomplete':
      $field_content = isset($items[$delta]['data']) ? $items[$delta]['data'] : '';
      $element['data'] = array(
        '#type' => 'hidden',
        '#default_value' => $field_content,
        '#attributes' => array(
          'class' => array(
            'ik-channel-filter-values',
          ),
        ),
      );

      /**
       * @todo: create them funtion for this
       *
       * theme('ik_channel_filter_results', $items[$delta]['results']);
       *
       */
      $output = '';
      if (!empty($field_content)) {
        $field_items = explode(',', $field_content);
        foreach ($field_items as $item) {
          $output .= '<li><span class="value">' . $item . '</span><a class="button ik-channel-filter-remove">' . t('Remove') . '</a></li>';
        }
      }

      $element['search']['results'] = array(
        '#prefix' => '<ul class="ik-channel-filter-results">',
        '#markup' => $output,
        '#suffix' => '</ul>',
      );

      $element['search']['field'] = array(
        '#type' => 'textfield',
        '#attributes' => array(
          'placeholder' => isset($instance['default_value'][$delta]['search']['field']) ? $instance['default_value'][$delta]['search']['field'] : 'Search',
        ),
        '#attached' => array(
          'js' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/js/ik_channel_filter.js',
          ),
          'css' => array(
            drupal_get_path('module', 'ik_channel_filter') . '/css/ik_channel_filter.css',
          ),
        ),
        '#autocomplete_path' => 'ik/autocomplete/' . $field['field_name'],
        '#required' => $element['#required'],
      );

      $element['search']['button'] = array(
        '#markup' => l(t('Add'), '#', array(
          'attributes' => array(
            'class' => array(
              'button',
              'ik-channel-filter-add-button',
            ),
          ),
        )),
      );

      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_error().
 *
 */
function ik_channel_filter_field_widget_error($element, $error, $form, &$form_state) {

}